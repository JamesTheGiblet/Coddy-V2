# C:\Users\gilbe\Documents\GitHub\Coddy V2\Coddy\tests\test_unit_tester_plugin.py

import unittest
from unittest.mock import patch, AsyncMock
from click.testing import CliRunner
from pathlib import Path
import ast # Import the ast module for syntax tree parsing

# Ensure this import path is correct for your project structure
from plugins.unit_tester_plugin.cli import unit_tester # Corrected import

class TestUnitTesterPlugin(unittest.TestCase):

    def setUp(self):
        self.runner = CliRunner()
        self.test_file = Path("module_for_testing.py") # Changed name to better reflect a module
        self.test_file.write_text("def add(a, b):\n    return a + b")

    def tearDown(self):
        if self.test_file.exists():
            self.test_file.unlink()
        # Clean up the generated test file as well
        generated_test_file = Path("tests") / f"test_{self.test_file.name}"
        if generated_test_file.exists():
            generated_test_file.unlink()
        # Clean up the 'tests' directory if it's empty after the test
        test_dir = Path("tests")
        if test_dir.exists() and not list(test_dir.iterdir()):
            test_dir.rmdir()


    @patch('plugins.unit_tester_plugin.cli.CodeGenerator')
    def test_unit_tester_command_success(self, MockCodeGenerator):
        """
        Tests the unit_test command successfully generates tests and reports success.
        """
        generated_content = (
            "import pytest\n"
            "from module_for_testing import add # Assuming 'add' is in the module_for_testing\n\n"
            "def test_add_example():\n"
            "    assert add(1, 2) == 3\n"
        )

        # Configure the mock instance and its async method
        mock_instance = MockCodeGenerator.return_value
        mock_instance.generate_tests_for_file = AsyncMock(return_value=generated_content)

        result = self.runner.invoke(unit_tester, [str(self.test_file)])

        self.assertEqual(result.exit_code, 0)
        self.assertIn(f"Generating unit tests for: {self.test_file.name}...", result.output)
        self.assertIn(f"Successfully generated test file at: tests\\test_{self.test_file.name}", result.output)
        
        # Verify the CodeGenerator was called with the correct content
        MockCodeGenerator.assert_called_once()
        # FIX HERE: Expect the second argument (the Path object)
        mock_instance.generate_tests_for_file.assert_awaited_once_with(self.test_file.read_text(), self.test_file) 
        # Note: self.test_file here is the Path object you created in setUp
        
        # Additional check: Verify the file was actually written with the mock content
        generated_file_path = Path("tests") / f"test_{self.test_file.name}"
        self.assertTrue(generated_file_path.exists())
        self.assertEqual(generated_file_path.read_text(encoding='utf-8'), generated_content)

    @patch('plugins.unit_tester_plugin.cli.CodeGenerator')
    def test_unit_tester_command_failure(self, MockCodeGenerator):
        """
        Tests the unit_test command handles errors during test generation.
        """
        mock_instance = MockCodeGenerator.return_value
        mock_instance.generate_tests_for_file = AsyncMock(side_effect=Exception("LLM Error"))

        result = self.runner.invoke(unit_tester, [str(self.test_file)])

        self.assertEqual(result.exit_code, 1)
        # Assert for the specific error message generated by the CLI
        self.assertIn("An error occurred during test generation: LLM Error", result.output)
        # You can optionally check for the traceback being present if that's desired behavior
        self.assertIn("Traceback (most recent call last):", result.output)


    @patch('plugins.unit_tester_plugin.cli.CodeGenerator')
    def test_generated_tests_are_syntactically_valid(self, MockCodeGenerator):
        """
        Tests that the generated test code is syntactically valid Python
        and the CLI reports success.
        """
        # A realistic example of what CodeGenerator might return for the test_file content
        # Note: Changed 'your_module' to 'module_for_testing' to match the created file
        sample_generated_pytest_code = (
            "import pytest\n"
            "from module_for_testing import add # Assuming 'add' is in a discoverable module\n\n"
            "def test_add_positive_numbers():\n"
            "    assert add(2, 3) == 5\n\n"
            "def test_add_negative_numbers():\n"
            "    assert add(-1, -1) == -2\n"
        )

        mock_instance = MockCodeGenerator.return_value
        mock_instance.generate_tests_for_file = AsyncMock(return_value=sample_generated_pytest_code)

        result = self.runner.invoke(unit_tester, [str(self.test_file)])

        self.assertEqual(result.exit_code, 0)
        # Assert for the specific success message now
        self.assertIn(f"Successfully generated test file at: tests\\test_{self.test_file.name}", result.output)

        # Crucial part: Attempt to parse the generated code using ast
        try:
            ast.parse(sample_generated_pytest_code)
        except SyntaxError as e:
            self.fail(f"Generated test code has a syntax error: {e}")

        # Additional check: Verify the file was actually written with the mock content
        generated_file_path = Path("tests") / f"test_{self.test_file.name}"
        self.assertTrue(generated_file_path.exists())
        self.assertEqual(generated_file_path.read_text(encoding='utf-8'), sample_generated_pytest_code)

# This assumes test_test_module_for_testing.py is a separate file that was generated.
# The NameError it's getting indicates it's trying to run a test from a file that 
# was previously generated by the unit_tester, but that generated test file
# isn't importing `add` correctly.

# The fix for test_test_module_for_testing.py::test_add (NameError) will depend
# on what the CodeGenerator actually outputs. The 'sample_generated_pytest_code'
# in your test_generated_tests_are_syntactically_valid method *does* include an import:
# "from your_module import add". The problem is that 'your_module' needs to be
# the actual name of the module that `add` is in (e.g., `module_for_testing`).

# If the CodeGenerator is using 'your_module', it needs to be updated to use the
# correct module name derived from the input file.

if __name__ == "__main__":
    unittest.main()